---
title: "Hands-on Exercise 3: Geographical Segmentation with Spatially Constrained Clustering Techniques"
editor: visual
---

## Overview

In this hands-on exercise, I learned how to delineate homogeneous region by using geographically referenced multivariate data. The two main types of analysis I learned are:

-   hierarchical cluster analysis

-   spatially constrained cluster analysis

## Getting Started

Firstly, we need to install the required R packages.

-   **sf**: importing, managing and processing geospatial data.

-   **spdep**: computing spatial weights and spatially lagged variables.

-   **tmap**: plotting Thematic Maps.

-   **tidyverse**: importing, wrangling and visualizing data. It consists of a family of R packages, including **readr**, **readxl**, **tidyr**, **dplyr** and **ggplot2**.

-   **rgdal**: handling geospatial data

-   **ggpubr:** facilitating **ggplot2** to make more visually appealing charts

-   **cluster:** performing cluster analysis

-   **factoextra:** extracting and visualizing the output of multivariate data analyses

-   **NbClust:** determining the best number of clusters in a data set

-   **heatmaply:** creating interactive cluster heatmaps

-   **corrplot:** plotting correlation matrix

-   **psych:** handling multivariate analysis

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, rgdal, ggpubr, cluster, factoextra, NbClust, heatmaply, corrplot, psych)

```

## Importing Required Data

### Importing geospatial data

The following codes import Myanmar Township Boundary GIS shapefile into R as a polygon feature data frame.

```{r}
shan_sf <- st_read(dsn = "data/geospatial",
                 layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)"))

```

The imported simple feature data frame is a multipolygon object. It contains 330 features and 14 fields. In addition, it's in WGS84 Coordinate System.

```{r}
shan_sf

```

The data frame is imported correctly after a brief visual check on the first 10 rows.

```{r}
glimpse(shan_sf)

```

The field types are correct as well.

### Importing the aspatial data

The following code chunk imports *InfoComm* data set into R as a tibble data frame. The data is extracted from The 2014 Myanmar Population and Housing Census Myanmar.

```{r}
ict <- read_csv("data/aspatial/Shan-ICT.csv")

```

The ict tibble data frame has 55 rows and 11 columns.

Let's take a look at the summary statistics of the columns.

```{r}
summary(ict)

```

There are 4 string columns and 7 numerical columns. No missing data exists in the numerical columns.

### Creating New Variables to Facilitate Our Analysis

Our analysis would be biased if we use the counts in the ict data frame to find the similar regions, because bigger regions would have more households and thus more sets of radio, tv etc. Penetration rate would be a better attribute to use in this analysis.

Therefore, let's calculate the penetration rate of the ict components base to the household numbers in the region. We also renamed the column names.

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`)

```

Let's take a look at the summary statistics of the derived data frame.

```{r}
summary(ict_derived)

```

We could see that six new columns for the penetration rate are created.

## Exploratory Data Analysis (EDA)

### EDA using statistical graphics

Let's start the data exploration from Histograms and Boxplots as the interested variables are numerical variables.

-   **Histogram:** to check the data distribution

    ```{r}
    radio_hist <- ggplot(data = ict_derived,
                         aes(x = `RADIO_PR`)) +
      geom_histogram(bins = 20,
                     color = "black",
                     fill = "light blue")

    tv_hist <- ggplot(data = ict_derived, 
                      aes(x = `TV_PR`)) +
      geom_histogram(bins = 20, 
                     color = "black", 
                     fill = "light blue")

    llphone_hist <- ggplot(data = ict_derived, 
                           aes(x = `LLPHONE_PR`)) +
      geom_histogram(bins = 20, 
                     color = "black", 
                     fill = "light blue")

    mphone_hist <- ggplot(data = ict_derived, 
                          aes(x = `MPHONE_PR`)) +
      geom_histogram(bins = 20, 
                     color = "black", 
                     fill = "light blue")

    computer_hist <- ggplot(data = ict_derived, 
                            aes(x = `COMPUTER_PR`)) +
      geom_histogram(bins = 20, 
                     color = "black", 
                     fill = "light blue")

    internet_hist <- ggplot(data = ict_derived, 
                            aes(x = `INTERNET_PR`)) +
      geom_histogram(bins = 20, 
                     color = "black", 
                     fill = "light blue")

    ggarrange(radio_hist, tv_hist, llphone_hist, mphone_hist, computer_hist, internet_hist, 
              ncol = 3, 
              nrow = 2)

    ```

    The histograms above show that the penetration rate for TV, radio and mobile phone are somewhat close to a bell shape, although the penetration rate for radio has a strike at around 80 making it possible for a bi-model distribution. On the other hand, the penetration rate for land line phone, computer and internet display a right skewed pattern.

-   **Boxplots:** to check for any outliers

    ```{r}
    radio_box <- ggplot(data = ict_derived,
                        aes(x = `RADIO_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    tv_box <- ggplot(data = ict_derived,
                     aes(x = `TV_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    llphone_box <- ggplot(data = ict_derived,
                          aes(x = `LLPHONE_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    mphone_box <- ggplot(data = ict_derived,
                         aes(x = `MPHONE_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    computer_box <- ggplot(data = ict_derived,
                           aes(x = `COMPUTER_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    internet_box <- ggplot(data = ict_derived,
                           aes(x = `INTERNET_PR`)) +
      geom_boxplot(color = "black",
                   fill = "light blue")

    ggarrange(radio_box, tv_box, llphone_box, mphone_box, computer_box, internet_box, 
              ncol = 3, 
              nrow = 2)

    ```

The box plots above show that there are a few outliers in all the penetration rates except that for mobile phone.

### EDA using choropleth map

**Joining geospatial data with aspatial data**

Let's now join the simple feature data frame, shan_sf, with the tibble data frame with the derived variables, ict_derived.

```{r}
shan_sf <- left_join(shan_sf,
                     ict_derived,
                     by = c("TS_PCODE" = "TS_PCODE"))
write_rds(shan_sf, "data/rds/shan_sf.rds")

```

**Preparing the choropleth map**

Let's first compare two pairs of choropleth maps

-   Total household number v.s. radio count

-   Total household number v.s. radio penetration rate

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)

```

We could see that the number of radios owned at township level is highly correlated with the number of households in the area. The towns with a larger number of households also own more radios.

However...

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins = 0, asp = 0)

```

Radio penetration rate doesn't display the same characteristic. The radio penetration rate could be small in the towns with more households, and it could be large in those towns with less household. Therefore, penetration rate is an unbiased attribute to describe the characteristics of the towns comparing to the counts.

## Correlation Analysis

Another thing we should check before performing cluster analysis is correlation analysis. If there are highly correlated variables, we should remove one of them to avoid multicollinearity.

Let's plot the correlation matrix.

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])

corrplot.mixed(cluster_vars.cor,
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")

```

We could see that computer penetration rate is positively strongly correlated with internet penetration rate with a correlation coefficient being 0.87. This makes sense because the households who own computers would get an internet broadband plan. Hence, we will exclude internet penetration rate from the cluster analysis.

## Hierarchy Cluster Analysis

### Extracting cluster variables

Let's first extract the cluster variables from shan_sf simple feature data frame to a new data frame.

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")

head(cluster_vars, 10)

```

Note that the purpose of st_set_geometry(NULL) command line is to drop the geometry information from the shan_sf simple feature data frame because we don't need it for hierarchy analysis.

We have also dropped the internet penetration rate, and so the data frame only contains the remaining five penetration rates.

Next, let's set the row name to the township names.

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)

```

Now let's drop the original township column and save it as another data frame.

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)

```

### Data standardization

The clustering variables need to be standardized and normalized if the variables are not in the same units and/or not in the same range. This is to avoid biased results by giving more weights to the variables with large values. There are a few methods to normalize the variables:

-   **Min-Max normalization**

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)

```

All the variables have the values ranged from 0 to 1 after min-max normalization.

-   **Z-score standardization:** if the variables follows normal distribution

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)

```

All the variables have mean equals to 0 and standard deviation equals to 1 after z-score standardization.

### Visualizing the standardized clustering variables

Let's check the distribution of the standardized variables using histogram and density plots.

-   **Radio penetration rate**

```{r}
r <- ggplot(data = ict_derived, 
            aes(x = `RADIO_PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data = shan_ict_s_df, 
            aes(x = `RADIO_PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data = shan_ict_z_df, 
            aes(x = `RADIO_PR`)) +
  geom_histogram(bins = 20, 
                 color = "black", 
                 fill = "light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)

```

```{r}
r <- ggplot(data = ict_derived, 
            aes(x= `RADIO_PR`)) +
  geom_density(color = "black",
               fill = "light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data = shan_ict_s_df, 
            aes(x = `RADIO_PR`)) +
  geom_density(color = "black",
               fill = "light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data = shan_ict_z_df, 
            aes(x = `RADIO_PR`)) +
  geom_density(color = "black",
               fill = "light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)

```

-   **TV penetration rate**
