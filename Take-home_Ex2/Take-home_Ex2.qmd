---
title: "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods"
editor: visual
---

## Background

Clustering analysis is a commonly used technique to find clusters among a population using different attributes. For example, the population of a country or region, the user market of a product, or the signals from some IoT devices.

Have you ever wondered if we could cluster regions? For example, are there any clusters among all the planning area in Singapore based on the attributes of interest? If we could find such clusters, then it might help business organizations to run targeted marketing campaigns or it could help the government to set better policies.

In this exercise, we'll apply different clustering methodologies to find clusters in Nigeria using their water point information as water supply is a major concern in the country. With this study, we hope to understand which region is facing severe water issues.

## Problem Statement

-   Apply conventional hierarchical clustering method to regionalize Nigeria using appropriate water point information
-   Apply spatially constrained clustering method to regionalize Nigeria using appropriate water point information
-   Information could be used to discover the clusters are:
    -   Total number of functional water points

    -   Total number of nonfunctional water points

    -   Percentage of functional water points

    -   Percentage of non-functional water points

    -   Percentage of main water point technology (i.e. Hand Pump)

    -   Percentage of usage capacity (i.e. \< 1000, \>=1000)

    -   Percentage of rural water points

## Getting Started

### Data sources

-   **Aspatial Data**

A set of a spatial data containing the water point related information is downloaded from [Water Point Data Exchange (WPdx)](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPdx-/eqje-vguj/data) website.

The original data set contains the data from 17 countries, and only the subset of Nigeria is used for the analysis in this exercise.

-   **Geospatial Data**

Nigeria Level-2 Administrative Boundary polygon features GIS data downloaded from [geoBoundaries](https://www.geoboundaries.org/) will be used in this exercise.

### Loading R Packages

First of all, let's load the required R packages into R:

-   **sf**: importing, managing and processing geospatial data.
-   **spdep**: computing spatial weights and spatially lagged variables.
-   **tmap**: plotting Thematic Maps.
-   **tidyverse**: importing, wrangling and visualizing data. It consists of a family of R packages, including **readr**, **readxl**, **tidyr**, **dplyr** and **ggplot2**.
-   **rgdal**: handling geospatial data
-   **ggpubr:** facilitating **ggplot2** to make more visually appealing charts
-   **cluster:** performing cluster analysis
-   **factoextra:** extracting and visualizing the output of multivariate data analyses
-   **NbClust:** determining the best number of clusters in a data set
-   **heatmaply:** creating interactive cluster heatmaps
-   **corrplot:** plotting correlation matrix
-   **psych:** handling multivariate analysis
-   **funModeling**: a tool box for data preparation and exploratory data analysis
-   **GGally:** extension of ggplot2 to reduce the complexity of combining geometric objects with transformed data

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, rgdal, ggpubr, cluster, factoextra, NbClust, heatmaply, corrplot, psych, funModeling, GGally)

```

### Importing Data

**Importing water point geospatial data**

Let's import the water point geospatial data into R as a point feature data frame.

```{r eval=FALSE}
wp <- st_read(dsn = "data/geo_export",
              layer = "geo_export",
              crs = 4326) %>%
  filter(clean_coun == "Nigeria")
```

There are a total of 406,566 features and 72 fields in the wp point feature data frame, and it's in WGS 84 coordinate system.

**Importing Nigeria LGA boundary data**

Now we'll import the LGA boundary data into R as a polygon feature data frame.

```{r}
nga <- st_read(dsn = "Data/geoBoundaries-NGA-ADM2-all",
               layer = "geoBoundaries-NGA-ADM2")

```

There are a total of 774 features and 5 fields in the nga multipolygon feature data frame, and it's also in WGS 84 coordinate system.

## Data Wrangling

### Nigeria LGA boundary data

Let's first take a look at the data structure to check if the data is imported correctly.

```{r}
glimpse(nga)

```

It seems that the data is in a good shape. Next, let's check if there is any duplicated polygons as they are supposed to be unique.

```{r}
n_occur <- data.frame(table(nga$shapeName))
n_occur[n_occur$Freq > 1,]
nga[nga$shapeName %in% n_occur$Var1[n_occur$Freq > 1], ]

```

Indeed, the table above shows that there are 6 pairs of duplicated polygons. However, they have different geometry values which suggests they are not the same regions.

Let's view those polygons with duplicated shapename in the map to validate our findings.

```{r}
nga_new <- left_join(nga, n_occur, by = c("shapeName" = "Var1"))

tm_shape(nga_new) +
  tm_polygons("Freq")

```

The polygons highlighted in orange are the ones with duplicate shapename. Indeed, those polygons are different regions in Nigeria. Let's label the polygons with shapeID for easy identification.

```{r}
tm_shape(nga_new) +
  tm_polygons() +
  tm_shape(filter(nga_new, Freq == 2)) +
  tm_polygons("shapeID") +
  tm_legend(legend.outside=TRUE)

```

By referencing to cirad Aware webpage for **Nigeria administrative boundaries (level 2)** ([link](https://aware.cirad.fr/layers/geonode:nigeria_adminboundaries_adm2_20170222_32631)) which is an interactive webpage to view geospatial data, we are able to identify the correct names for the polygons.

+----------------------------+--------------------+---------------------+
| shapeID                    | Original shapeName | Correct shapeName   |
+============================+====================+=====================+
| NGA-ADM2-72505758B95534398 | Bassa              | Bassa (Kogi)        |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B52690633 | Bassa              | Bassa (Plateau)     |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B26581542 | Ifelodun           | Ifelodun (Kwara)    |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B18326272 | Ifelodun           | Ifelodun (Osun)     |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B75034141 | Irepodun           | Irepodun (Kwara)    |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B79178637 | Irepodun           | Irepodun (Osun)     |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B6786568  | Nasarawa           | Nasarawa (Kano)     |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B67188591 | Nasarawa           | Nasarawa (Nasarawa) |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B7318634  | Obi                | Obi (Benue)         |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B3073896  | Obi                | Obi (Nasarawa)      |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B6675111  | Surulere           | Surulere (Lagos)    |
+----------------------------+--------------------+---------------------+
| NGA-ADM2-72505758B31597260 | Surulere           | Surulere (Oyo)      |
+----------------------------+--------------------+---------------------+

: Now, let's rectify the shape names for the 6 pairs of polygons with duplicated names.

```{r}
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B95534398"] <- "Bassa (Kogi)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B52690633"] <- "Bassa (Plateau)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B26581542"] <- "Ifelodun (Kwara)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B18326272"] <- "Ifelodun (Osun)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B75034141"] <- "Irepodun (Kwara)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B79178637"] <- "Irepodun (Osun)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B6786568"] <- "Nasarawa (Kano)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B67188591"] <- "Nasarawa (Nasarawa)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B7318634"] <- "Obi (Benue)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B3073896"] <- "Obi (Nasarawa)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B6675111"] <- "Surulere (Lagos)"
nga_new$shapeName[nga_new$shapeID == "NGA-ADM2-72505758B31597260"] <- "Surulere (Oyo)"

nga_new <- nga_new[, 1:5]

```

Let's check if the shape names are unique now.

```{r}
n_occur <- data.frame(table(nga_new$shapeName))
n_occur[n_occur$Freq > 1,]
nga_new[nga_new$shapeName %in% n_occur$Var1[n_occur$Freq > 1], ]

```

The report above shows that there isn't any duplicated shapename in the data frame now.

### Water point geospatial data

Let's now check if the water point data is imported correctly.

```{r eval=FALSE}
glimpse(wp)

```

It seems that the data is imported properly. However, there are NA values in the character columns. Therefore, we need to recode them into Unknown for better interpretation.

### **Recoding NA values into string**

Let's recode NA in all the character columns into Unknown.

```{r eval=FALSE}
wp <- wp %>%
  mutate_if(is.character, ~replace_na(., "Unknown"))

```

```{r eval=FALSE}
glimpse(wp)

```

### **Drop non-useful columns**

There are a total 73 columns in the wp feature data frame, but we don't need all of them in the clustering analysis. In this exercise, we'll focus on the attributes in the table below.

+------------------------------------------------------------+-------------+-------------------------------------------+
| Attributes                                                 | Column Name | Levels in Column                          |
+============================================================+=============+===========================================+
| -   Total number of functional water points                | status_cle  | -   Abandoned                             |
| -   Total number of nonfunctional water points             |             | -   Abandoned/Decommissioned              |
| -   Percentage of functional water points                  |             | -   Functional                            |
| -   Percentage of nonfunctional water points               |             | -   Functional but needs repair           |
|                                                            |             | -   Functional but not in use             |
|                                                            |             | -   Non-Functional                        |
|                                                            |             | -   Non-Functional due to dry season      |
|                                                            |             | -   Non functional due to dry season      |
|                                                            |             | -   Unknown                               |
+------------------------------------------------------------+-------------+-------------------------------------------+
| Percentage of main water point technology (i.e. Hand Pump) | X_water_tec | -   Hand Pump                             |
|                                                            |             | -   Mechanized Pump                       |
|                                                            |             | -   Rope and Bucket                       |
|                                                            |             | -   Tapstand                              |
|                                                            |             | -   Unknown                               |
+------------------------------------------------------------+-------------+-------------------------------------------+
| Percentage of usage capacity (i.e. \< 1000, \>=1000)       | usage_cap   |                                           |
+------------------------------------------------------------+-------------+-------------------------------------------+
| Percentage of rural water points                           | is_urban    | -   True                                  |
|                                                            |             | -   False                                 |
+------------------------------------------------------------+-------------+-------------------------------------------+
| Percentage of water source                                 | water_so_2  | -   Piped Water                           |
|                                                            |             | -   Spring                                |
|                                                            |             | -   Well                                  |
|                                                            |             | -   Unknown                               |
+------------------------------------------------------------+-------------+-------------------------------------------+
| Percentage of management institute                         | manageme_2  | -   Community Management                  |
|                                                            |             | -   Direct Government Operation           |
|                                                            |             | -   Health Care Facility                  |
|                                                            |             | -   Other Institutional Management        |
|                                                            |             | -   Private Operator/Delegated Management |
|                                                            |             | -   School Management                     |
|                                                            |             | -   Other                                 |
|                                                            |             | -   Unknown                               |
+------------------------------------------------------------+-------------+-------------------------------------------+

### Exploratory Data Analysis (EDA)

Let's now take a look at the distribution of the selected columns.

**Water Points Status**

```{r eval=FALSE}
freq(data=wp, 
     input = 'status_cle')

```

We'll group the categories into 3 groups:

-   Functional
-   Non-functional including non-functional and abandoned water points
-   Unknown

**Water Point Technology**

```{r eval=FALSE}
freq(data=wp, 
     input = 'X_water_tec')

```

We'll focus on hand pump and mechanized pump in the subsequent analysis because the other types have very little instances.

**Usage Capacity**

```{r eval=FALSE}
freq(data=wp, 
     input = 'usage_cap')

```

We'll group the values into two groups:

-   \<1000
-   \>= 1000

**Rural vs Urban**

```{r eval=FALSE}
freq(data=wp, 
     input = 'is_urban')

```

**Water Source**

```{r eval=FALSE}
freq(data=wp, 
     input = 'water_so_2')

```

The plot above shows that 96.35% of the water points are from well, and there are only 3.65% of the water points are from spring, piped water and unknown sources. As well is the dominant source, we'll drop this variable from subsequent analysis.

**Management Institute**

```{r eval=FALSE}
freq(data=wp, 
     input = 'manageme_2')

```

We'll combine the small categories into Others in the clustering analysis:

-   School Management (1.51%)
-   Health Care Facility (0.46%)
-   Private Operator/Delegated Management (0.20%)
-   Other Institutional Management (0.14%)
-   Other (8.80%)

## Extracting Water Point Data

### Extracting functional water point

We'll first extract the data for functional water points.

```{r eval=FALSE}
wp_functional <- wp %>%
  filter(status_cle %in%
           c("Functional", 
             "Functional but not in use",
             "Functional but needs repair"))

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_functional, 
     input = 'status_cle')

```

### Extracting non-functional water point

Next we'll extract the data for non-functional water points.

```{r eval=FALSE}
wp_nonfunctional <- wp %>%
  filter(status_cle %in%
           c("Abandoned/Decommissioned", 
             "Abandoned",
             "Non-Functional",
             "Non functional due to dry season",
             "Non-Functional due to dry season"))

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_nonfunctional, 
     input = 'status_cle')

```

### Extracting hand pump water point

Next we'll extract the data for hand pump water points.

```{r eval=FALSE}
wp_handpump <- wp %>%
  filter(X_water_tec == 'Hand Pump')

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_handpump, 
     input = 'X_water_tec')

```

### Extracting mechanized pump water point

Next we'll extract the data for mechanized pump water points.

```{r eval=FALSE}
wp_mechpump <- wp %>%
  filter(X_water_tec == 'Mechanized Pump')

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_mechpump, 
     input = 'X_water_tec')

```

### Extracting water points with usage capacity \< 1000

Next we'll extract the data for water points with usage capacity \< 1000.

```{r eval=FALSE}
wp_use1000l <- wp %>%
  filter(usage_cap < 1000)

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_use1000l, 
     input = 'usage_cap')

```

### Extracting water points with usage capacity \>= 1000

Next we'll extract the data for water points with usage capacity \>= 1000.

```{r eval=FALSE}
wp_use1000m <- wp %>%
  filter(usage_cap >= 1000)

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_use1000m, 
     input = 'usage_cap')

```

### Extracting rural water points

Next we'll extract the data for rural water points.

```{r eval=FALSE}
wp_rural <- wp %>%
  filter(is_urban == 'False')

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_rural, 
     input = 'is_urban')

```

### Extracting community managed water points

Next we'll extract the data for community managed water points.

```{r eval=FALSE}
wp_comm <- wp %>%
  filter(manageme_2 == 'Community Management')

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_comm, 
     input = 'manageme_2')

```

### Extracting government managed water points

Next we'll extract the data for government managed water points.

```{r eval=FALSE}
wp_gov <- wp %>%
  filter(manageme_2 == 'Direct Government Operation')

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_gov, 
     input = 'manageme_2')

```

### Extracting water points managed by other institutes

Next we'll extract the data for water points managed by other institutes.

```{r eval=FALSE}
wp_othmanage <- wp %>%
  filter(manageme_2 %in%
           c("Health Care Facility", 
             "Other",
             "Other Institutional Management",
             "Private Operator/Delegated Management",
             "School Management"))

```

Let's check the distribution.

```{r eval=FALSE}
freq(data=wp_othmanage, 
     input = 'manageme_2')

```

## Performing Point-in-Polygon Count

Next we'll count the number of water points regarding the above attributes in each polygon, and join the counts with the geoboundary data.

```{r eval=FALSE}
nga_wp <- nga_new %>% 
  mutate(`total wpt` = lengths(
    st_intersects(nga, wp))) %>%
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wp_functional))) %>%
  mutate(`wpt non-functional` = lengths(
    st_intersects(nga, wp_nonfunctional))) %>%
  mutate(`wpt hand pump` = lengths(
    st_intersects(nga, wp_handpump))) %>%
  mutate(`wpt mechanized pump` = lengths(
    st_intersects(nga, wp_mechpump))) %>%
  mutate(`wpt cap 1000 less` = lengths(
    st_intersects(nga, wp_use1000l))) %>%
  mutate(`wpt cap 1000 more` = lengths(
    st_intersects(nga, wp_use1000m))) %>%
  mutate(`wpt rural` = lengths(
    st_intersects(nga, wp_rural))) %>%
  mutate(`wpt manage community` = lengths(
    st_intersects(nga, wp_comm))) %>%
  mutate(`wpt manage government` = lengths(
    st_intersects(nga, wp_gov))) %>%
  mutate(`wpt manage other` = lengths(
    st_intersects(nga, wp_othmanage)))

```

Next we'll compute the percentage of the attributes as the absolute counts may lead to biased results.

```{r eval=FALSE}
nga_wp <- nga_wp %>%
  mutate(`pct_functional` = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%
  mutate(`pct_handpump` = `wpt hand pump`/`total wpt`) %>%
  mutate(`pct_mechanizedpump` = `wpt mechanized pump`/`total wpt`) %>%
  mutate(`pct_capacity1000less` = `wpt cap 1000 less`/`total wpt`) %>%
  mutate(`pct_capacity1000more` = `wpt cap 1000 more`/`total wpt`) %>%
  mutate(`pct_rural` = `wpt rural`/`total wpt`) %>%
  mutate(`pct_communitymanaged` = `wpt manage community`/`total wpt`) %>%
  mutate(`pct_governmentmanaged` = `wpt manage government`/`total wpt`) %>%
  mutate(`pct_othermanaged` = `wpt manage other`/`total wpt`) 

```

## Saving the Analytical Data Table

Now we have prepared our analytical data table, and let's save it for subsequent uses.

```{r eval=FALSE}
write_rds(nga_wp, "data/nga_wp.rds")

```

## Visualizing the Spatial Distribution of Water Points

Let's first import the analytical data table.

```{r}
nga_wp <- read_rds("data/nga_wp.rds")

```

Next, we'll study the distribution of the new attributes derived earlier, and plot them on the choropleth map to learn their geospatial distribution.

### **Histograms**

```{r fig.height=10, fig.width=10}
hist_functional <- ggplot(data = nga_wp,
                          aes(x = `pct_functional`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Functional Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_nonfunctional <- ggplot(data = nga_wp,
                          aes(x = `pct_non-functional`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Non-functional Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_handpump <- ggplot(data = nga_wp,
                          aes(x = `pct_handpump`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Hand Pump Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_mechanizedpump <- ggplot(data = nga_wp,
                          aes(x = `pct_mechanizedpump`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Mechanized Pump Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_capacity1000less <- ggplot(data = nga_wp,
                          aes(x = `pct_capacity1000less`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Water Points with User Capacity < 1000 (%)") +
  theme(plot.title = element_text(size = 9, hjust = 0.5))

hist_capacity1000more <- ggplot(data = nga_wp,
                          aes(x = `pct_capacity1000more`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Water Points with User Capacity >= 1000 (%)") +
  theme(plot.title = element_text(size = 9, hjust = 0.5))

hist_rural <- ggplot(data = nga_wp,
                          aes(x = `pct_rural`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Rural Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_communitymanaged <- ggplot(data = nga_wp,
                          aes(x = `pct_communitymanaged`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Community Managed Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_governmentmanaged <- ggplot(data = nga_wp,
                          aes(x = `pct_governmentmanaged`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Government Managed Water Points (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

hist_othermanaged <- ggplot(data = nga_wp,
                          aes(x = `pct_othermanaged`)) +
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "light blue") +
  ggtitle("Water Points Managed by Other Institutes (%)") +
  theme(plot.title = element_text(size = 10, hjust = 0.5))

ggarrange(hist_functional, 
          hist_nonfunctional, 
          hist_handpump, 
          hist_mechanizedpump, 
          hist_capacity1000less, 
          hist_capacity1000more,
          hist_rural,
          hist_communitymanaged,
          hist_governmentmanaged,
          hist_othermanaged,
          ncol = 3, 
          nrow = 4)

```

The plots above reveals the distribution of the newly derived attributes. Some of them slightly resemble normal distribution, but most of them are skewed.

**Slightly resemble normal distribution:**

-   percentage of functional water points
-   percentage of non-functional water points

**Skewed to the right:**

-   percentage of echanized pump water points
-   percentage of water points with user capacity \>= 1000
-   percentage of community managed water points
-   percentage of government managed water points
-   percentage of water points managed by other institutes

**Skewed to the left:**

-   percentage of water points with user capacity \< 1000
-   percentage of rural water points

**Bimodel:**

-   percentage of hand pump water points

### Choropleth Map

Let's also plot the distribution on the geoboundary map.

```{r fig.height=30, fig.width=10}
map_functional <- tm_shape(nga_wp) +
  tm_fill(col = "pct_functional",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Functional Water Points (%)",
            title.position = c("center", "top"))

map_nonfunctional <- tm_shape(nga_wp) +
  tm_fill(col = "pct_non-functional",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Non-functional Water Points (%)",
            title.position = c("center", "top"))

map_handpump <- tm_shape(nga_wp) +
  tm_fill(col = "pct_handpump",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Hand Pump Water Points (%)",
            title.position = c("center", "top"))

map_mechanizedpump <- tm_shape(nga_wp) +
  tm_fill(col = "pct_mechanizedpump",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Mechanized Pump Water Points (%)",
            title.position = c("center", "top"))

map_capacity1000less <- tm_shape(nga_wp) +
  tm_fill(col = "pct_capacity1000less",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Water Points with User Capacity < 1000 (%)",
            title.position = c("center", "top"))

map_capacity1000more <- tm_shape(nga_wp) +
  tm_fill(col = "pct_capacity1000more",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Water Points with User Capacity >= 1000 (%)",
            title.position = c("center", "top"))

map_rural <- tm_shape(nga_wp) +
  tm_fill(col = "pct_rural",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Rural Water Points (%)",
            title.position = c("center", "top"))

map_communitymanaged <- tm_shape(nga_wp) +
  tm_fill(col = "pct_communitymanaged",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Community Managed Water Points (%)",
            title.position = c("center", "top"))

map_governmentmanaged <- tm_shape(nga_wp) +
  tm_fill(col = "pct_governmentmanaged",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Government Managed Water Points (%)",
            title.position = c("center", "top"))

map_othermanaged <- tm_shape(nga_wp) +
  tm_fill(col = "pct_othermanaged",
          n = 5,
          style = "jenks",
          title = "Percentage") +
  tm_borders(alpha = 0.5) +
  tm_layout(title = "Water Points Managed by Other Institutes (%)",
            title.position = c("center", "top"))

tmap_arrange(map_functional, 
             map_nonfunctional,
             map_handpump,
             map_mechanizedpump,
             map_capacity1000less,
             map_capacity1000more,
             map_rural,
             map_communitymanaged,
             map_governmentmanaged,
             map_othermanaged,
             asp=0, ncol=2)

```

We could deduce a few interesting findings from the plots above:

-   The water points in the northern part Nigeria are mostly functional, but that in southern part are mostly non-functional.
-   The water points in the northern part are mostly using hand pump except the regions in the northeast, and most of the water points in the southern part are using mechanized pump.
-   Similarly, the water points in the northern part are mostly with a smaller user capacity (\< 1000) except the regions in the northeast, but most of the water points in the southern part are with larger user capacity (\> 1000).
-   Most of the water points in the central regions are managed by community, those in the north-eastern regions are mainly managed by government. The water points in the southern and south-eastern regions are mostly managed by other institute.
-   Water points in the rural regions are observed across the whole country

## Correlation Analysis

Before we perform the clustering analysis, we need to check if any of the interested attributes are strongly correlated. We could construct a correlation matrix to check.

```{r fig.height=10, fig.width=10}
cluster_vars <- nga_wp %>% st_set_geometry(NULL)
cluster_vars.cor = cor(cluster_vars[,17:26], use = "complete.obs")
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")

```

The correlation matrix reveals that the technology used at the water points are strongly correlated with their user capacity. Therefore, we'll exclude the user capacity variables and mechanized pump variable in the clustering analysis. In other words, the following variables will not be used:

-   pct_mechanizedpump
-   pct_capacity1000less
-   pct_capacity1000more

## Hierarchy Cluster Analysis

Now, we are ready to apply the clustering analysis.

### Extracting clustering variables

Let's first extract the variables that will be used in clustering analysis.

```{r}
cluster_vars <- cluster_vars %>% select("shapeName",
                                        "pct_functional",
                                        "pct_non-functional",
                                        "pct_handpump",
                                        "pct_rural",
                                        "pct_communitymanaged",
                                        "pct_governmentmanaged",
                                        "pct_othermanaged")

head(cluster_vars)

```

Next, we'll set the shape name as the row names.

```{r}
row.names(cluster_vars) <- cluster_vars$shapeName
head(cluster_vars)

```

Next, we'll delete the shape name column.

```{r}
nga_wp_hca <- select(cluster_vars, c(2:8))
head(nga_wp_hca)

```

### Data standardization

Sometimes we'd standardize the data using z transformation or min-max transformation because the variables are not in the same range. For example, if we have variables like likert scales having values from 1 to 10 and also variables like income having values from a few hundreds to thoursands, then we should transform the values into a similar range to avoid biased results.

In our exercise, since we have computed the percentage of all the attributes and all of them are within the range from 0 to 1, it isn't necessary for us to perform standardization on the variables. We'll use the computed variables to perform clustering analysis.

### Computing proximity matrix

Next, we'll calculate the proximity matrix using euclidean distance. However, we noticed that there are some rows with NA in the clustering data frame. We'll remove the rows with NA first.

```{r}
nga_wp_hca_com <- nga_wp_hca[complete.cases(nga_wp_hca),]

```

```{r}
proxmat <- dist(nga_wp_hca_com, method = 'euclidean')
proxmat

```

### Computing hierarchical clustering

Next, we'll perform hierarchical clustering analysis using ward.D method.

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')

```

We could plot the dendrogram of the clusters.

```{r}
plot(hclust_ward, cex = 0.6)

```

### Selecting the optimal clustering algorithm

Next, since there are multiple methods available in hierarchical clustering, we'll compute the agglomerative coefficient to determine which one is the best for our data. Agglomerative coefficient is used to measure the amount of clustering structure found in the data. Values closer to 1 suggest strong clustering structure.

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(nga_wp_hca_com, method = x)$ac
}

map_dbl(m, ac)

```

The output above reveals that Ward's method has the highest agglomerative coefficient, which indicates that it's the best method for this data set. Therefore, we'll use Ward's method in the subsequent analysis.

### Determining Optimal Clusters

Next, we'll use gap statistic method to determine the optimal number of clusters.

The [**gap statistic**](http://www.web.stanford.edu/~hastie/Papers/gap.pdf) compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.

```{r}
set.seed(12345)
gap_stat <- clusGap(nga_wp_hca_com, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")

```

Let's plot the gap statistic against the clusters for easier analysis.

```{r}
fviz_gap_stat(gap_stat)

```

The plot above shows that the recommended number of clusters is 8. Although the gap statistic at 9 clusters is the highest, there isn't a significant increment from 8 clusters. Therefore, we'll use 8 clusters as suggested.

### Interpreting the dendrogram

Now, we'll highlight the 8 clusters in the dendrogram.

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 8, 
            border = 2:5)

```

### Visually-driven hierarchical clustering analysis

It's not so easy to understand the characteristics of the clusters from the dendrogram. We'll then build an interactive cluster heatmap to understand more about the clusters.

**Transforming the data frame into a matrix**

In order to plot a heatmap, we need to convert the data frame to a matrix.

```{r}
nga_wp_hca_mat <- data.matrix(nga_wp_hca_com)

```

**Plotting interactive cluster heatmap**

```{r}
heatmaply(normalize(nga_wp_hca_mat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 8,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="Geographic Segmentation of Nigeria by Water Point Indicators",
          xlab = "Water Point Indicators",
          ylab = "Regions in Nigeria"
          )

```

### Mapping the clusters formed

Next, we'll join the clusters' information with the original simple feature object to plot the clusters on the choropleth map.

```{r}
groups <- as.factor(cutree(hclust_ward, k=8))

```

```{r}
nga_wp_hca_cluster <- cbind(cbind(rownames(nga_wp_hca_com), data.frame(nga_wp_hca_com, row.names = NULL)), as.matrix(groups)) %>%
  select(c(1,9)) %>%
  rename(`shapeName` = `rownames(nga_wp_hca_com)`,
         `CLUSTER` = `as.matrix(groups)`)

head(nga_wp_hca_cluster)
  
```

```{r}
nga_wp_cluster <- left_join(nga_wp, nga_wp_hca_cluster, by = "shapeName")

head(nga_wp_cluster)

```

```{r}
qtm(nga_wp_cluster, "CLUSTER")

```

It's an interesting map, but the region in the clusters are scattered around which makes it challenging for interpretation.

In the next section, we'll apply the spatially constrained clustering method to improve the clusters.

## Spatially Constrained Clustering: SKATER approach 

### Converting into SpatialPolygonsDataFrame

First of all, we need to convert the simple feature data frame into SpatialPolygonsDataFrame because SKATER function only support sp objects such as SpatialPolygonDataFrame.

```{r}
nga_wp_sp <- as_Spatial(nga_wp)

```

### Computing neighbour list

Next, we compute the neighbour list from the polygon list.

```{r}
nga_wp.nb <- poly2nb(nga_wp_sp)
summary(nga_wp.nb)

```

The summary report above reveals that the average neighbours for a region in Nigeria is 5.74. There is one region not linked to any neighbours, and there is one region with 14 neighbours.

We'll need to remove the polygon with no links in order to carry on with the edge cost calculation.

```{r}
nga_wp.nb.sub <- subset(nga_wp.nb, subset=card(nga_wp.nb) > 0)
nga_wp_sp.sub <- subset(nga_wp_sp, subset=card(nga_wp.nb) > 0)
nga_wp_hca.sub <- subset(nga_wp_hca, subset=card(nga_wp.nb) > 0)
nga_wp_hca.sub[is.na(nga_wp_hca.sub)] = 0
nga_wp_cluster.sub <- subset(nga_wp_cluster, subset=card(nga_wp.nb) > 0)

```

We could plot the neighbour list on the geoboundaries.

```{r fig.height=10, fig.width=10}
plot(nga_wp_sp.sub, 
     border=grey(.5))
plot(nga_wp.nb.sub, 
     coordinates(nga_wp_sp.sub), 
     col="blue", 
     add=TRUE)

```

### **Calculating edge costs**

Next, we'll calculate the cost of each edge which is the distance between its nodes.

```{r}
lcosts <- nbcosts(nga_wp.nb.sub, nga_wp_hca.sub)

```

Now we have calculated the pairwise dissimilarity between it's values on the water point variables and the values for the neighbouring observations. In other words, we have constructed the weights for a spatial weights matrix.

Next, we'll convert the nerighbour list to a list weights object by specifying lcosts as the weights.

```{r}
nga_wp.sub.w <- nb2listw(nga_wp.nb.sub, 
                   lcosts, 
                   style="B",
                   zero.policy = TRUE)
summary(nga_wp.sub.w)

```

### Computing minimum spanning tree

Next, we'll calculate the minimum spanning tree.

```{r}
nga_wp.sub.mst <- mstree(nga_wp.sub.w)

class(nga_wp.sub.mst)

```

```{r}
dim(nga_wp.sub.mst)

```

The dimension of 772 x 3 is correct because the minimum spanning tree consists of n-1 edges (links) in order to traverse all the nodes

```{r}
head(nga_wp.sub.mst)

```

Next, let's plot the MST on the geoboundaries.

```{r fig.height=10, fig.width=10}
plot(nga_wp_sp.sub, border=gray(.5))
plot.mst(nga_wp.sub.mst, 
         coordinates(nga_wp_sp.sub), 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)

```

### Computing spatially constrained clusters using SKATER method

We'll now compute the spatially constrained cluster using 8 clusters.

```{r}
clust8 <- spdep::skater(edges = nga_wp.sub.mst[,1:2], 
                 data = nga_wp_hca.sub, 
                 method = "euclidean", 
                 ncuts = 7)

```

Note that the number of cuts is one less than the desired number of clusters.

```{r}
str(clust8)

```

The groups vector in the SKATER output contains the cluster group each observation belongs to. We could check the cluster groups using the code below.

```{r}
ccs8 <- clust8$groups
ccs8

```

We can find out the cluster size for each cluster.

```{r}
table(ccs8)

```

Cluster 6 has the least observations of 20, and cluster 8 is the largest with 284 observations.

We then plot the pruned tree that shows the 8 clusters on top of the geoboundaries.

```{r fig.height=20, fig.width=20}
plot(nga_wp_sp.sub, border=gray(.5))
plot(clust8, 
     coordinates(nga_wp_sp.sub), 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink", "black", "orange", "yellow"),
     cex.circles=0.005, 
     add=TRUE)

```

### Visualizing the clusters in choropleth map

We can now plot the newly derived clusters from SKATER method.

```{r fig.height=10, fig.width=10}
groups_mat <- as.matrix(clust8$groups)
nga_wp_spatialcluster.sub <- cbind(nga_wp_cluster.sub, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)

qtm(nga_wp_spatialcluster.sub, "SP_CLUSTER")

```

For easy comparison, we could plot the hierarchical clustering map together with the spatially constrained clustering map.

```{r fig.height=5, fig.width=10}
hclust.map <- qtm(nga_wp_spatialcluster.sub,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(nga_wp_spatialcluster.sub,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=0, ncol=2)

```

The plots above shows that the regions in the clusters from spatially constrained clustering method are not as scattered as that from the hierarchical clustering analysis. This would be more helpful for the decision makers to draw geospatial conclusions.

## Visual Interpretation of Clusters

### Summary statistics of the clusters

```{r}
nga_wp_spatialcluster.sub %>% 
  st_set_geometry(NULL) %>%
  group_by(CLUSTER) %>%
  summarise(mean_functional = mean(pct_functional),
            mean_nonfunctional = mean(`pct_non.functional`),
            mean_handpump = mean(pct_handpump),
            mean_rural = mean(pct_rural),
            mean_communitymanaged = mean(pct_communitymanaged),
            mean_governmentmanaged = mean(pct_governmentmanaged),
            mean_othermanaged = mean(pct_othermanaged))

```

### Multivariate Visualization

```{r}
ggparcoord(data = nga_wp_spatialcluster.sub, 
           columns = c(17:19,23:26), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of Water Points by Cluster") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 90))

```

We could observe there are some distinctive difference among the clusters from the plot above:

**Cluster 1:** most regions are urban area having functional water points with mechanized pumps. Nevertheless, a few region have high percentage of non-functional water points.

**Cluster 2:** most regions are in rural area having functional water points with hand pumps.

**Cluster 3:** most regions are in rural area having non-functional water points with mechanized pumps.

**Cluster 4:** most regions are in rural area having non-functional water points with hand pumps.

**Cluster 5:** most regions are in rural area having a mix of functional and non-functional water points using mechanized pumps.

**Cluster 6:** most regions are in urban area having a mix of functional and non-functional water points using hand pumps.

**Cluster 7:** most regions are in rural area having functional water points managed by government. These water points are also using mechanized pumps.

**Cluster 8:** most of the regions are in rural area having functional water points managed by community. Those water points are also using mechanized pumps.

## Conclusion

We have applied both hierarchical clustering and spatially constrained clustering methods on the Nigeria water points data set. Spatially constrained clustering method indeed provide better clusters when geospatial information need to be considered for the analysis. It provides better interpretation, and the constrained clusters are more insightful for the business decision makers to draw strategic conclusions.

### Future Work

-   Methodology: we applied SKATER method to perform spatially constrained clustering analysis in this exercise. There are also other methods like ClustGeo method. For future work, we could compare different methods to assess which one gives better clusters with more distinctive characteristics.

-   Attribute dimension: in this exercise, we evaluated the functional status of the water points, their water sources, the technology used, the area type, user capacity and their management institutes. For future work, we could extend the analysis to include more attributes such as the local population, the age of the water points and the distance to road / city.

**Thank you!**

